#!/usr/bin/env bash

###############################################################################
#     INFO
###############################################################################
#
# This script setups a management system for configuring
# environment variables.
#
# HOW TO SETUP
# 1. Run this script.
#    It will create and populate the path: $HOME/.config/env/
#    It will also add two scripts to $HOME/.local/bin/: envmgr and pathmgr
#
# 2. Edit your shellrc file so it sources one of the helper scripts.
#      POSIX: $HOME/.config/env/load.sh
#      Bash:  $HOME/.config/env/load.sh
#      Zsh:   $HOME/.config/env/load.zsh
#      Csh:   $HOME/.config/env/load.csh
#      Tcsh:  $HOME/.config/env/load.csh
#
# 3. Add a *.env file in $HOME/.config/env/ for each
#    environment variable you want, and make them executable.
#      Example: cat <<EOF >$HOME/.config/env/EDITOR.env
#               #!/usr/bin/env bash
#               echo "vim"
#               EOF
#      Example: cat <<EOF >$HOME/.config/env/GIT_PAGER.env
#               #!/usr/bin/env python3
#               print("less -FRX --mouse")
#               EOF
#    Alternatively, use the helper scripts envmgr and pathmgr.
#      Example: envmgr add EDITOR vim
#      Example: pathmgr add '$HOME/.local/cargo/bin'
#
# HOW TO REMOVE
#   Remove the load script from your shellrc file.
#   Delete $HOME/.local/bin/pathmgr
#   Delete $HOME/.local/bin/envmgr
#   Delete the folder: $HOME/.config/env/


###############################################################################
#     GENERAL SETUP
###############################################################################

# Create directories
mkdir -p "$HOME/.config/env"
mkdir -p "$HOME/.local/bin"

# Create PATH.env
cat > "$HOME/.config/env/PATH.env.template" <<'EOF'
#!/usr/bin/env bash
# Owned by pathmgr
set -Eeuo pipefail  # Crash if any undeclared variables are used (+ more)

PATH="$HOME/.local/bin:$PATH"
PATH="$HOME/bin:$PATH"

### NO TOUCHY UNDER THIS LINE ###

# Remove duplicate PATH entries 
declare _PATH="" path=""
while [[ "$PATH" == *:* ]]; do
  path="${PATH%%:*}"  # Ex: "aa:bb:cc" => "aa"
  PATH="${PATH#*:}"   # Ex: "aa:bb:cc" => "bb:cc"
  [[ ":$PATH:" == *":$path:"* ]] && continue  # Check if duplicate
  _PATH="$_PATH:$path"
done
PATH="${_PATH}:${PATH}"
PATH="${PATH#:}"  # Remove ':' at the beginning of string

# Print
echo "$PATH"
EOF

if [[ ! -e "$HOME/.config/env/PATH.env" ]]; then
  cp "$HOME/.config/env/PATH.env.template" "$HOME/.config/env/PATH.env"
  chmod a+x "$HOME/.config/env/PATH.env"
fi

# Create env manager
cat > "$HOME/.local/bin/envmgr" <<'EOF'
#!/usr/bin/env bash
set -Eeuo pipefail
shopt -s extglob
CDPATH=''

readonly script="envmgr"
readonly work_dir="$HOME/.config/env"
readonly owner_string='Generated by envmgr'
readonly command="${1-}"
readonly env_name="${2-}"
readonly env_value="${3-}"

if [[ ! -d "$work_dir" ]]; then
  echo >&2 "[envmgr] Directory not found: $work_dir"
  exit 1
fi

function usage() {
  echo "USAGE: ${script} add NAME VALUE"
  echo "       ${script} remove NAME"
  echo "       ${script} list"
  echo "       ${script} version"
}

function env_add() {
  #using global: work_dir
  #using global: owner_string
  local name="$1"
  local value="$2"
  local file="${work_dir}/${name}.env"

  cat > "${file}" <<END
#!/usr/bin/env bash
# ${owner_string}
echo "$env_value"
END

  chmod a+x "${file}"
}

function is_ok_to_modify_file() {
  #using global: work_dir
  #using global: owner_string
  local name="$1"
  local file="${work_dir}/${name}.env"
  local msg=""
  local result=0

  if [[ "$name" == "PATH" ]]; then
    result=1
    msg="Err: Use pathmgr for editing PATH"
  elif [[ ! -e "$file" ]]; then
    result=0
  elif [[ -d "$file" ]]; then
    result=1
    msg="Err: ENV file is a directory: $file"
  elif [[ ! -x "$file" ]]; then
    result=1
    msg="${msg}Err: ENV file is not executable.\n"
    msg="${msg}     file: $file\n"
    msg="${msg}     File will not be modified."
  elif ! grep --quiet --fixed-strings "$owner_string" "$file"; then
    result=1
    msg="${msg}Err: ENV '$name' is not managed by $script.\n"
    msg="${msg}     file: $file\n"
    msg="${msg}     Either edit the file manually OR delete it and try again."
  fi

  [[ -n "$msg" ]] && echo >&2 "$msg"
  return $result
}

case "$command" in
      (add) [[ -z "$env_name" || -z "$env_value" ]] && usage >&2 && exit 1
            is_ok_to_modify_file "$env_name" || { usage >&2; exit 1; }
            env_add "$env_name" "$env_value" ;;
   (remove) [[ -z "$env_name" ]] && usage >&2 && exit 1
            is_ok_to_modify_file "$env_name" || { usage >&2; exit 1; }
            rm --force -- "${work_dir}/${env_name}.env" ;;
     (list) for file in "${work_dir}"/*.env; do
              declare name="$( basename "$file" | sed -E 's/\.env$//' )"
              declare value="$( "$file" )"
              value="${value//\"/\\\"}"  # " => \"
              echo "${name}"░="\"${value}\""
            done \
                 | column -t -s░                                               \
                 | sed 's/  =/ = /'                                            \
                 | awk -F ''                                                   \
                       -v TERMWIDTH="$(tput cols </dev/tty)"                   \
                       'match($0, /^[^=]+ *= *"/) {                            \
                          LENGTH=TERMWIDTH-RLENGTH;                            \
                          HEAD=substr($0, RSTART, RLENGTH);                    \
                          for (i=RSTART+RLENGTH; i <= length($0); i+=LENGTH) { \
                            for(i=i; $i==" "; i++) {};                         \
                            print HEAD substr($0, i, LENGTH);                  \
                            HEAD=sprintf("%0*s", RLENGTH, "")                  \
                          }                                                    \
                        }'                                                    ;;
  (version) echo 'envmgr v0.0.3 (aaaaaabbbbbbccccccddddddeeeeeeffffff0125) 2023-06-12T14:41:00+02:00' ;;

  (help|-help|--help|-h|-\?) usage ;;
  (*)                        usage >&2 && exit 1 ;;
esac
EOF
chmod a+x "$HOME/.local/bin/envmgr"

# Create path manager
cat > "$HOME/.local/bin/pathmgr" <<'EOF'
#!/usr/bin/env bash
set -Eeuo pipefail
shopt -s extglob
CDPATH=''

# This script is basically mimicing pathman:
# https://github.com/therootcompany/pathman

readonly script="pathmgr"
readonly work_dir="$HOME/.config/env"
readonly owner_string='Owned by pathmgr'
readonly path_file="$HOME/.config/env/PATH.env"
readonly command="${1-}"
readonly path="${2-}"
readonly protoPATH="$( env --ignore-environment sh -c 'echo "$PATH"' )"

if [[ ! -d "$work_dir" ]]; then
  echo >&2 "[envmgr] Directory not found: $work_dir"
  exit 1
elif [[ ! -f "$path_file" ]]; then
  echo >&2 "Err: File not found: $path_file"
  exit 1
fi

function usage() {
  echo "USAGE: ${script} add APATH"
  echo "       ${script} add-last APATH"
  echo "       ${script} remove APATH"
  echo "       ${script} list"
  echo "       ${script} version"
}

function is_ok_to_use_path_file() {
  #using global: work_dir
  #using global: owner_string
  #using global: path_file
  readonly file="$path_file"
  local msg=""
  local result=0

  if [[ ! -e "$file" ]]; then
    result=1
    msg="${msg}Err: File not found: $file"
    msg="${msg}     "
  elif [[ -d "$file" ]]; then
    result=1
    msg="Err: PATH file is a directory: $file"
  elif [[ ! -x "$file" ]]; then
    result=1
    msg="${msg}Err: PATH file is not executable.\n"
    msg="${msg}     file: $file\n"
    msg="${msg}     File will not be modified."
  elif ! grep --quiet --fixed-strings "$owner_string" "$file"; then
    result=1
    msg="${msg}Err: PATH file is not managed by $script.\n"
    msg="${msg}     file: $file\n"
    msg="${msg}     Either edit the file manually OR create a new file from the template and try again:\n"
    msg="${msg}     template: $file.template"
  fi

  [[ -n "$msg" ]] && echo -e >&2 "$msg"
  return $result
}

case "$command" in
     (list) is_ok_to_use_path_file || exit 1
            declare pathmgrPATHs="$( PATH="$protoPATH" "$path_file" | sed 's/:/\n/g' | grep -v -f <(sed 's/^/^/;s/:/\n^/g' <<<"$protoPATH") )"
            declare otherPATHs="$( "$path_file" | sed 's/:/\n/g' | grep -v -f <(sed 's/^/^/' <<<"$pathmgrPATHs") )"
            echo 'pathmgr-managed PATH entries:'
            echo
            sed 's/^/\t/' <<<"$pathmgrPATHs"
            echo
            echo 'other PATH entries:'
            echo
            sed 's/^/\t/' <<<"$otherPATHs"
            echo ;;
      (add) [[ -z "$path" ]] && usage >&2 && exit 1
            is_ok_to_use_path_file || exit 1
            sed --in-place --regexp-extended '/^PATH=/,/TOUCHY/{ /^\s*$/N; /TOUCHY/s,^,PATH="'"$path"':$PATH"\n, }' "$path_file" ;;
 (add-last) [[ -z "$path" ]] && usage >&2 && exit 1
            is_ok_to_use_path_file || exit 1
            sed --in-place --regexp-extended '/^PATH=/,/TOUCHY/{ /^\s*$/N; /TOUCHY/s,^,PATH=$PATH:"'"$path"'"\n, }' "$path_file" ;;
   (remove) [[ -z "$path" ]] && usage >&2 && exit 1
            is_ok_to_use_path_file || exit 1
            declare rem_path="$( eval "echo \"$path\"" )"  # Shell expansion
            declare line_no=0 line="" old_path=""
            for line_no in $(sed -n '/^PATH/=;/TOUCHY/q' "$path_file"); do
              line="$(sed -n "${line_no}p" "$path_file")"
              old_path="$(PATH="$protoPATH"; eval "$line"; sed -E "s,:?$protoPATH:?,," <<<"$PATH")"
              if [[ "$old_path" == "$rem_path" ]]; then
                sed --in-place "${line_no}d" "$path_file"
                break
              fi
            done ;;
            
  (version) echo 'pathmgr v0.0.9 (aaaaaabbbbbbccccccddddddeeeeeeffffff0123) 2023-05-26T16:48:00+02:00' ;;
        (*) usage >&2 && exit 1 ;;
esac
EOF
chmod a+x "$HOME/.local/bin/pathmgr"

# Hijack pathman
#if [[ ! -e "$HOME/.local/bin/pathman" ]]; then
#  ln -s pathmgr "$HOME/.local/bin/pathman"
#fi


###############################################################################
#     SHELL SPECIFICS
###############################################################################

# csh and tsch
cat > "$HOME/.config/env/load.csh" <<'EOF'
# SCRIPT INTENT:
#   foreach x ("$HOME"/.config/env/*.env)
#     set e = "` basename "$x" | sed 's/[.]env$//' `"
#     set v = "` $x `"
#     eval "setenv $e $v"
#   end
#
# FEATURES THAT MAKES THIS SCRIPT COMPLICATED:
# - Retry *.env files multiple times.
#   This solves the problem where one environment variable is
#   dependent on another environment variable. A *.env file just
#   need to explicitly fail if required varibles are not available
#   yet.

set env_files = ""  # List of files, separated by ':'

foreach env_file ("$HOME"/.config/env/*.env)
  # Ignore files with illegal variable names
  basename "$env_file" | sed 's/[.]env$//' | grep --quiet '[^_A-Za-z0-9]' && continue

  # Ignore files that are not executable
  [ ! -f "$env_file" -a ! -x "$env_file" ] && continue

  # Add file to list
  set env_files = "$env_files":"$env_file"
end
set env_files = "` echo '$env_files' | sed 's/^://' `"

# Calculate max numbers of loops before script will stop
set env_files_count="` echo :'$env_files' | grep -Fo ':' | wc -l `"
@ loop_max = ( $env_files_count * 4 )  # Magic number

# Add environment variables
foreach _ (`seq 1 $loop_max`)
  [ "$env_files" == "" ] && break

  set env_file  = "` echo '$env_files' | sed -E 's/:.*"'$'"//' `"
  set env_files = "` echo '$env_files' | sed -E 's/^[^:]+:?//' `"
 
  set env_name  = "` basename '$env_file' | sed 's/[.]env"'$'"//' `"
  set env_value = "` sh -c '$env_file 2>/dev/null' `"  # Execute *.env file

  if ( $? != 0 ) then  # If execution of *.env failed
    set env_files = "$env_files":"$env_file"  # Try *.env file again later
    set env_files = "` echo '$env_files' | sed 's/^://' `"
  else
    eval "setenv $env_name '$env_value'"
  endif
end

[ -n "$env_files" ] && sh -c "echo >&2 'Error loading the following environment variable files: $env_files'"

unset env_files env_file env_name env_value
unset env_files_count loop_max
EOF

# Bash and POSIX Shell
cat > "$HOME/.config/env/load.sh" <<'EOF'
# SCRIPT INTENT:
#   for x in "$HOME"/.config/env/*.env; do
#     e="$( basename "$x" | sed 's/[.]env$//' )"
#     declare $e="$( $x )"
#     export $e
#   done
#
# FEATURES THAT MAKES THIS SCRIPT COMPLICATED:
# - Retry *.env files multiple times.
#   This solves the problem where one environment variable is
#   dependent on another environment variable. A *.env file just
#   need to explicitly fail if required varibles are not available
#   yet.

env_files=""  # List of files, separated by ':'

for env_file in "$HOME"/.config/env/*.env; do
  # Ignore files with illegal variable names
  basename "$env_file" | sed 's/[.]env$//' | grep --quiet '[^_A-Za-z0-9]' && continue

  # Ignore files that are not executable
  [ ! -x "$env_file" ] && continue

  # Add file to list
  env_files="$env_files:$env_file"
done
env_files="$( echo "$env_files" | sed 's/^://' )"

# Calculate max numbers of loops before script will stop
env_files_count="$( echo ":$env_files" | grep -Fo ':' | wc -l )"
loop_max="$(( env_files_count * 4 ))"  # Magic number

# Add environment variables
for _ in $(seq 1 $loop_max); do
  [ "$env_files" == "" ] && break

  env_file="$(  echo "$env_files" | sed -E 's/:.*$//'     )"
  env_files="$( echo "$env_files" | sed -E 's/^[^:]+:?//' )"

  env_name="$( basename "$env_file" | sed 's/[.]env$//' )"
  env_value="$( "$env_file" 2> /dev/null )"  # Execute *.env file

  if [ $? != 0 ]; then  # If execution of *.env failed
    env_files="$env_files:$env_file"  # Try *.env file again later
    env_files="$( echo "$env_files" | sed 's/^://' )"
  else
    declare $env_name="$env_value"
    export $env_name
  fi
done

[ -n "$env_files" ] && echo >&2 "Error loading the following environment variable files: $env_files"

unset env_files env_file env_name env_value
unset env_files_count loop_max
EOF

# zsh
ln -sf "load.sh" "$HOME/.config/env/load.zsh"

